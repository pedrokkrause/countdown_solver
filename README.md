# Countdown Solver

This project provides a solver for the game **Countdown**. First, every possible arithmetic expression that can be built from a set of six numbers, using the operations `+`, `-`, `*`, and `/`, are generated. Expressions with parenthesis, like `(a+(b+c)*d)/(e-f)`, are also fully included. The solver then uses this pregenerated set of expressions to compute every possible value from 6 provided numbers, finding the one closest to the given target.

---

## How It Works

### Compacted vs. Expanded Approaches

#### **Compacted Expressions**

* **What are they?**
  A minimal set of “expression templates” (distinct forms with parentheses and operations, but without fixed numbers).
* **How are they used?**
  For each puzzle, the solver tests every permutation of the input numbers (720 for six numbers) against each compacted template. Since there are 3,444 compacted expressions, this gives at most a total of 3,444*720 = 2,479,680 evaluations.
  
  *Example*: For the template `a+b+c+d+e+f`, all possible orders of the six numbers are tried—even though all permutations return the same value for this particular template.
* **Efficiency:**
  Requires little memory and loads quickly, but involves redundant evaluations when an expression's result doesn't change with number order (e.g., all additions).

#### **Expanded Expressions**

* **What are they?**
  Every unique expression generated by applying all number permutations to all compacted templates, and removing duplicates (i.e., expressions that evaluate to the same value). This gives 970,324 unique expressions, a reduction of x2.55 from the 2,479,680 expressions needed when using the compacted set.
* **How are they used?**
  For each puzzle, every unique expression is evaluated *once* (with the numbers in their original order), eliminating redundant computations.
* **Efficiency:**
  Much faster at evaluation (since it avoids repetition), but has a significant initial load time and higher memory usage, as every unique expression must be parsed to create its own lambda function.

---

## Solvers

* **Compacted Solver (`c_solver.py`):**
  Loads the compacted expression templates and evaluates all number permutations for each template.
  **Best for:** Quick startup and solving a small number of problems.

* **Expanded Solver (`e_solver.py`):**
  Loads every unique, fully-expanded expression and evaluates each with the numbers in input order (no redundant checks).
  **Best for:** Solving many puzzles in a row (batch mode), if you don’t mind a longer startup time.

**Summary of trade-offs:**

* **Compacted = fast startup, more redundant computation.**
* **Expanded = slow startup, no redundant computation, potentially faster overall for large batches.**

---

## Hard Problem Finder

The `hard_problems_finder.py` script searches for Countdown puzzles that are maximally challenging—those that have a solution, but for which all other expressions are as far as possible from the target.

**Hardest problem found so far:**

```
Numbers: 28, 74, 6, 73, 1, 47
Target: 984
```

---

## File Overview

* `generate_compacted.py`: Generates the compacted expression templates.
* `generate_expanded.py`: Applies all permutations to templates and filters for unique expressions.
* `c_solver.py`: Efficient solver using compacted templates (recommended for quick use).
* `e_solver.py`: Exhaustive solver using unique expanded expressions (recommended for batch solving).
* `hard_problems_finder.py`: Finds especially hard Countdown problems.
